/*
package org.daijb.huat.services;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.sql.DataSource;
import java.io.File;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ExecutorService;

*/
/**
 * @author daijb
 * @date 2021/2/18 10:35
 *//*

public class ExternalDomainExecutive {

    private static final Logger logger = LoggerFactory.getLogger(ExternalDomainExecutive.class);

    static class EntityInfo {
        String l7p;
        double flowSize;
        String ip;
        Integer areaId;
        JSONObject attrs = new JSONObject();
        String groupId;
    }

    @Autowired
    private BORepository repository;

    @Autowired
    private BeansContainer beansContainer;

    @Autowired
    private ExecutorService executorService;

    private volatile int maxHits = 10000;

    @EventListener(ApplicationReadyEvent.class)
    public void onApplicationReadyEvent(ApplicationReadyEvent event) {
        execFunc(true);
    }

    @Scheduled(cron = "0 0/60 * * * ?")
    public void startThreadFunc() {
        execFunc(false);
    }

    private void execFunc(boolean isFirst) {
        if (!SystemUtil.isApplicationMasterMode()) {
            return;
        }
        final String index = getSearchIndex();
        StringBuilder sql = new StringBuilder(128);
        sql.append("SELECT * FROM ");
        boolean hasIndex = false;
        if (isFirst) {
            try {
                File file = new File("/etc/csp/external");
                if (!file.exists()) {
                    file.mkdirs();
                    setElasticSearchMaxHits(1024 * 300, index);
                    sql.append(visitRelation + "*");
                    hasIndex = true;
                }
            } catch (Throwable throwable) {
                hasIndex = true;
                sql.append(index);
            }
        } else {
            hasIndex = true;
            setElasticSearchMaxHits(maxHits, index);
            sql.append(index);
        }
        if (!hasIndex) {
            setElasticSearchMaxHits(maxHits, index);
            sql.append(index);
        }
        sql.append("/").append(visitRelation).append(" WHERE ")
                .append(" l7p in ('pop3','http','ssh','imap','smtp','ftp') ")
                .append(" limit ").append(maxHits);
        String eventMetaId = "g_visit_relation_asset";
        String queryExpr = sql.toString();
        Map<String, Object> params = new HashMap<>(8);
        params.put("eventMetaId", eventMetaId);
        params.put("queryExpr", queryExpr);
        executorService.execute(() -> {
            searchVisitRelation(params);
            asyncSaveToDataBase();
        });
    }

    private final List<EntityInfo> cacheEntityInfos = new ArrayList<>();

    */
/**
     * 查询互访关系图
     *//*

    public synchronized void searchVisitRelation(Map<String, Object> params) {
        JSONArray jsonArray = null;
        try {
            long t0 = System.currentTimeMillis();
            jsonArray = elasticSearchService.search(params);
            maxHits = ConversionUtil.toInt(params.get("totalRows"));
            long t1 = System.currentTimeMillis();
            logger.info("query es expr : " + params.toString() + " , data size : " + (jsonArray == null ? 0 : jsonArray.size()) + " in " + (t1 - t0) + "ms");
        } catch (Throwable throwable) {
            logger.error("search visit relation for elasticsearch failed ", throwable);
        }
        if (jsonArray == null) {
            logger.warn("query es index : " + params.get("eventMetaId")
                    + " is not exist , searchExpr : " + params.get("queryExpr") + "");
            return;
        }
        Map<Integer, Map<String, Set<String>>> groupMemberIdAtIps = searchGroupMemberIdAtIps();
        Set<String> ignoreIp = new HashSet<>();
        for (Object o : jsonArray) {
            JSONObject json = (JSONObject) o;
            Object areaId = json.get("area_id");
            if (null != areaId) {
                Integer areaId0 = ConversionUtil.toInt(areaId);
                Map<String, Set<String>> groupsIdAtIps = groupMemberIdAtIps.get(areaId0);
                if (groupsIdAtIps == null || groupsIdAtIps.isEmpty()) {
                    continue;
                }
                // 匹配了同一个自定义组内所有的ip 导致错误
                String srcIp = ConversionUtil.toString(json.get("srcip"));
                String dstIp = ConversionUtil.toString(json.get("dstip"));
                String l7p = ConversionUtil.toString(json.get("l7p"));
                double flowSize = ConversionUtil.toDouble(json.get("total_flow_size"));
                boolean isIgnoreSrcIp = true, isIgnoreDstIp = true;

                for (Map.Entry<String, Set<String>> entry : groupsIdAtIps.entrySet()) {
                    Set<String> ips = entry.getValue();
                    String groupId = entry.getKey();
                    if (ips.contains(srcIp)) {
                        isIgnoreSrcIp = false;
                        createEntityInfo(areaId0, flowSize, srcIp, groupId, l7p);
                    }
                    if (ips.contains(dstIp)) {
                        isIgnoreDstIp = false;
                        createEntityInfo(areaId0, flowSize, dstIp, groupId, l7p);
                    }
                }
                if (isIgnoreDstIp && isIgnoreSrcIp) {
                    ignoreIp.add(srcIp);
                    ignoreIp.add(dstIp);
                }
            }
        }
        if (logger.isDebugEnabled()) {
            logger.debug("external domain ignore ips : " + ignoreIp);
        }
    }

    private List<EntityInfo> updateCacheEntityInfos() {
        List<EntityInfo> entityInfos = new ArrayList<>();
        for (EntityInfo entityInfo : cacheEntityInfos) {
            if (entityInfos.isEmpty()) {
                entityInfos.add(entityInfo);
                continue;
            }
            String groupId = entityInfo.groupId;
            String ip = entityInfo.ip;
            boolean has = false;
            for (EntityInfo entityInfo1 : entityInfos) {
                if (StringUtil.equals(ip, entityInfo1.ip) && StringUtil.equals(groupId, entityInfo1.groupId)) {
                    entityInfo1.flowSize = entityInfo1.flowSize + entityInfo.flowSize;
                    has = true;
                    break;
                }
            }
            if (!has) {
                entityInfos.add(entityInfo);
            }
        }
        cacheEntityInfos.clear();
        return entityInfos;
    }

    private void asyncSaveToDataBase() {
        LocalDateTime now = LocalDateTime.now();
        final String time = now.getYear()
                + "-" + String.format("%02d", now.getMonthValue())
                + "-" + String.format("%02d", now.getDayOfMonth())
                + " " + String.format("%02d", now.getHour());
        DataSource dataSource = beansContainer.getBean(DataSource.class);
        try (final Connection conn = dataSource.getConnection()) {
            long t1 = System.currentTimeMillis();
            // 设置手动提交
            conn.setAutoCommit(false);
            String insertSql = "INSERT INTO stat_dwd_asset_con_hour (stat_hour,area_id,l7p,flow_size,obj_ip,attrs,group_id) VALUES (?,?,?,?,?,?,?);";
            PreparedStatement psts = conn.prepareStatement(insertSql);
            List<EntityInfo> entityInfos = updateCacheEntityInfos();
            for (EntityInfo entityInfo : entityInfos) {
                psts.setString(1, time);
                psts.setString(2, ConversionUtil.toString(entityInfo.areaId));
                psts.setString(3, ConversionUtil.toString(entityInfo.l7p));
                psts.setString(4, ConversionUtil.toString(entityInfo.flowSize));
                psts.setString(5, ConversionUtil.toString(entityInfo.ip));
                psts.setString(6, entityInfo.attrs.isEmpty() ? "" : ConversionUtil.toString(entityInfo.attrs));
                psts.setString(7, ConversionUtil.toString(entityInfo.groupId));
                // 加入批量处理
                psts.addBatch();
            }
            // 执行批量处理
            psts.executeBatch();
            // 提交
            conn.commit();
            long t2 = System.currentTimeMillis();
            logger.info("table stat_dwd_asset_con_hour batch save data size : " + entityInfos.size() + " finished in " + (t2 - t1) + "ms");
            psts = null;
            cacheEntityInfos.clear();
        } catch (Throwable t) {
            logger.error("batch save data to stat_dwd_asset_con_hour0 failed.", t);
        }
    }

    private void createEntityInfo(Integer areaId, Double flowSize, String ip, String groupId, String l7p) {
        EntityInfo entityInfo = new EntityInfo();
        entityInfo.areaId = areaId;
        entityInfo.flowSize = flowSize;
        entityInfo.ip = ip;
        entityInfo.l7p = l7p;
        entityInfo.groupId = groupId;
        cacheEntityInfos.add(entityInfo);
    }

    */
/**
     * key:自定义组id
     * value: HashMap == > key：groupId  value：该自定义组内所有ip
     *//*

    private synchronized Map<Integer, Map<String, Set<String>>> searchGroupMemberIdAtIps() {
        Map<Integer, Map<String, Set<String>>> allGroupMemberIps0 = new HashMap<>();
        List<GroupMember> groupMembers = repository.search(GroupMember.class, null);
        for (GroupMember groupMember : groupMembers) {
            String entityId = groupMember.getEntityId();
            String groupId = groupMember.getGroupId();
            Asset asset = repository.get(Asset.class, entityId);
            Integer areaId = asset.getAreaId();
            if (allGroupMemberIps0.get(areaId) == null) {
                Map<String, Set<String>> map = new HashMap<>();
                Set<String> ips = new HashSet<>(Asset.getIps(asset));
                map.put(groupId, ips);
                allGroupMemberIps0.put(areaId, map);
            } else {
                // 同一个区域多个自定义组情况
                Map<String, Set<String>> map = allGroupMemberIps0.get(areaId);
                Set<String> ips = map.get(groupId);
                if (ips == null) {
                    ips = new HashSet<>();
                }
                ips.addAll(Asset.getIps(asset));
                map.put(groupId, ips);
                allGroupMemberIps0.put(areaId, map);
            }
        }
        return allGroupMemberIps0;
    }

    private final String visitRelation = "g_visit_relation_asset";

    */
/**
     * 获取查询索引
     *//*

    private String getSearchIndex() {
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE, -1);
        return visitRelation + "-" + df.format(calendar.getTime());
    }

    private synchronized void setElasticSearchMaxHits(int maxHits0, String index) {
        try {
            if (maxHits0 <= 10000) {
                maxHits0 = 10000;
            }
            this.maxHits = maxHits0;
            ProcessBuilder processBuilder = new ProcessBuilder();
            processBuilder.command("bash", "/etc/csp/bin/setElasticSearchMaxTotal.sh", index, ConversionUtil.toString(maxHits));
            processBuilder.start();
        } catch (Throwable throwable) {
            logger.error("config elasticsearch maxTotal failed", throwable);
        }
    }
}
*/
